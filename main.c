#include "stm32f10x.h"
#include "stm32_can.h"
#include "stm32_gpio.h"

#define WAIT_TIMEOUT 0x03FF

struct canRxMsg
{
    volatile uint32_t rxMsgL[3];
    volatile uint32_t rxMsgH[3];
    volatile uint32_t rxMsgId[3];
    volatile uint32_t rxMsgDlTS[3];
    volatile uint8_t rxMsgFOV;
    volatile uint8_t rxMsgFUL;
} canRx0Msg, canRx1Msg;

/*
The FIFO 0 interrupt can be generated by the following events:
– Reception of a new message, FMP0 bits in the CAN_RF0R register are not ‘00’.
– FIFO0 full condition, FULL0 bit in the CAN_RF0R register set.
– FIFO0 overrun condition, FOVR0 bit in the CAN_RF0R register set.
CAN_RF0R
CAN_RI0R
CAN_RDT0R
CAN_RDL0R
CAN_RDH0R
*/
void USB_LP_CAN_RX0_IRQHandler(void)
{   
    uint16_t waitTime = 0x0000;
    static uint8_t  messageCnt = 0;

    canRx0Msg.rxMsgFOV = CAN1->RF0R & CAN_RF0R_FOVR0 ? 1 : 0;
    CAN1->RF0R |= CAN1->RF0R & CAN_RF0R_FOVR0 ? CAN_RF0R_FOVR0 : 0;
    canRx0Msg.rxMsgFUL = CAN1->RF0R & CAN_RF0R_FULL0 ? 1 : 0;
    CAN1->RF0R |= CAN1->RF0R & CAN_RF0R_FULL0 ? CAN_RF0R_FULL0 : 0;

    messageCnt = (CAN1->RF0R & CAN_RF0R_FMP0);
    while( messageCnt != 0 && waitTime != WAIT_TIMEOUT)
    {
        CAN1->RF0R |= CAN_RF0R_RFOM0;
        canRx0Msg.rxMsgId[messageCnt-1] = CAN1->sFIFOMailBox[0].RIR;
        canRx0Msg.rxMsgDlTS[messageCnt-1] = CAN1->sFIFOMailBox[0].RDTR;
        canRx0Msg.rxMsgL[messageCnt-1] = CAN1->sFIFOMailBox[0].RDLR;
        canRx0Msg.rxMsgH[messageCnt-1] = CAN1->sFIFOMailBox[0].RDHR;
        messageCnt = (CAN1->RF0R & CAN_RF0R_FMP0);

        waitTime++;
    }
}

void CAN_RX1_IRQHandler(void)
{

}

void CAN_SCE_IRQHandler(void)
{

}

int main(void)
{
    initGPIO();
    canPinInit();
    canInit();

    return 0;
}